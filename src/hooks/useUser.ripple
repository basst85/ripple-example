import { track, effect } from 'ripple';

interface User {
	id: number;
	firstName: string;
	lastName: string;
	email: string;
	phone: string;
	username: string;
	image: string;
	address: {
		address: string;
		city: string;
		state: string;
		country: string;
	};
	company: {
		name: string;
		title: string;
	};
	age: number;
	gender: string;
}

const fetchUser = async (userId: number): Promise<User> => {
	const response = await fetch(`https://dummyjson.com/users/${userId}`);

	if (!response.ok) {
		throw new Error(`Failed to fetch user ${userId}`);
	}

	return response.json();
};

const unwrapTrackedValue = (maybe: any) => {
	if (maybe && typeof maybe === 'object') {
		if ('v' in maybe) {
			return maybe.v;
		}

		if (typeof maybe.valueOf === 'function') {
			const value = maybe.valueOf();

			if (value !== maybe) {
				return value;
			}
		}
	}

	return maybe;
};

const resolveUserId = (userId: any): number => {
	const unwrapped = unwrapTrackedValue(userId);

	if (typeof unwrapped === 'number') {
		return unwrapped;
	}

	if (typeof unwrapped === 'string') {
		const parsed = parseInt(unwrapped, 10);
		return Number.isFinite(parsed) ? parsed : NaN;
	}

	const numeric = Number(unwrapped);
	return Number.isFinite(numeric) ? numeric : NaN;
};

export const useUser = (userId: any) => {
	const user = track<User | null>(null);
	const loading = track(true);
	const error = track<string | null>(null);

	// Re-fetch when userId changes
	effect(() => {
		// Use @ to properly access the tracked value and establish reactivity
		const currentUserId = typeof userId === 'object' && 'v' in userId ? @userId : userId;
		const resolvedId = resolveUserId(currentUserId);
		const isValidId = Number.isFinite(resolvedId) && resolvedId > 0 && resolvedId <= 208;

		if (!isValidId) {
			@loading = false;
			@error = 'Invalid user id';
			@user = null;
			return;
		}

		@loading = true;
		@error = null;

		fetchUser(resolvedId)
			.then(result => {
				@user = result;
			})
			.catch(err => {
				@error = err instanceof Error ? err.message : 'An error occurred';
				console.error(`Failed to fetch user ${resolvedId}:`, err);
			})
			.finally(() => {
				@loading = false;
			});
	});

	const refetch = () => {
		const currentUserId = typeof userId === 'object' && 'v' in userId ? @userId : userId;
		const resolvedId = resolveUserId(currentUserId);
		const isValidId = Number.isFinite(resolvedId) && resolvedId > 0 && resolvedId <= 208;

		if (!isValidId) {
			@loading = false;
			@error = 'Invalid user id';
			return;
		}

		@loading = true;
		@error = null;

		fetchUser(resolvedId)
			.then(result => {
				@user = result;
			})
			.catch(err => {
				@error = err instanceof Error ? err.message : 'An error occurred';
				console.error(`Failed to fetch user ${resolvedId}:`, err);
			})
			.finally(() => {
				@loading = false;
			});
	};

	return {
		user,
		loading,
		error,
		refetch
	};
};